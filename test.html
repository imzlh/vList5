<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Document</title>
</head>

<body style="margin: 0;">
    <div id="fps">0</div>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script>
        // fps
        const fps = document.getElementById('fps');

        // 创建场景
        const scene = new THREE.Scene();

        // 创建相机
        const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
        camera.position.z = 5;

        // 创建渲染器
        const renderer = new THREE.WebGLRenderer();
        renderer.setSize(window.innerWidth, window.innerHeight);
        document.body.appendChild(renderer.domElement);

        // 创建星星粒子
        const starGeometry = new THREE.BufferGeometry();
        const starMaterial = new THREE.PointsMaterial({ color: 0xffffff, size: 1, transparent: true, opacity: 0.8 });
        
        // 初始化星星位置
        const starVertices = [];
        const starOpacity = [];
        for (let i = 0; i < 80000; i++) {
            const x = THREE.MathUtils.randFloatSpread(4000);
            const y = THREE.MathUtils.randFloatSpread(3000);
            const z = THREE.MathUtils.randFloatSpread(6000);
            starVertices.push(x, y, z);
            starOpacity.push(Math.random()); // 随机初始透明度
        }
        
        starGeometry.setAttribute('position', new THREE.Float32BufferAttribute(starVertices, 3));
        starGeometry.setAttribute('opacity', new THREE.Float32BufferAttribute(starOpacity, 1));
        
        const stars = new THREE.Points(starGeometry, starMaterial);
        scene.add(stars);
        
        let render_fps = 0;
        function animate() {
            const positions = starGeometry.attributes.position.array;
            const opacities = starGeometry.attributes.opacity.array;

            requestAnimationFrame(animate);
            render_fps ++;

            if (camera.position.z < -1000){
                camera.position.z = 0;
                for(let i = 0; i < opacities.length; i++){
                    opacities[i] = Math.random();
                }
                return;
            }
        
            for (let i = 0; i < opacities.length; i++) {
                opacities[i] = Math.sin(performance.now() / 500 + positions[i * 3] * 0.01) * 0.5 + 0.5;
            }
            starGeometry.attributes.opacity.needsUpdate = true;
        
            camera.position.z -= 1;
            stars.rotation.x += 0.001;
            stars.rotation.y += 0.002;
        
            renderer.render(scene, camera);
        }
        
        setInterval(function(){
            fps.innerHTML = render_fps;
            render_fps = 0;
        }, 1000);

        // 调整窗口大小时更新渲染器和相机
        window.addEventListener('resize', () => {
            renderer.setSize(window.innerWidth, window.innerHeight);
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
        });

        // 开始动画
        animate();
    </script>
    <style>
        canvas{
            width: 100%;
            height: 100%;
        }

        #fps{
            font-size: 20px;
            position: fixed;
            top: 1rem;
            left: 1rem;
            color: white;
        }

        #fps::after{
            content: ' fps';
            color: gray;
        }
    </style>
</body>

</html>